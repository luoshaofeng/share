# Info

Redis6.0



# 增量同步

## 从库加载RDB文件

redis的增量同步信息保存在RDB文件中

- 服务启动时，会加载RDB配置（如果开启的话）

```c
void loadDataFromDisk(void) {
    long long start = ustime();
    // 如果aof是开启的
    if (server.aof_state == AOF_ON) {
        ……
    } else {        // aof没开就加载rdb文件
        rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;
        errno = 0; /* Prevent a stale value from affecting error checking */
        // 加载rdb文件
        if (rdbLoad(server.rdb_filename, &rsi,RDBFLAGS_NONE) == C_OK) {
            ……
        } else if (errno != ENOENT) {
            ……
        }
    }
}
```

- 从rdb文件中加载增量同步所需的信息

  - master的runid
  - 偏移量
  - 当前选中的数据库

  ```c
  int rdbLoad(char *filename, rdbSaveInfo *rsi, int rdbflags) {
      FILE *fp;
      rio rdb;
      int retval;
  
      if ((fp = fopen(filename,"r")) == NULL) return C_ERR;
      ……
      retval = rdbLoadRio(&rdb,rdbflags,rsi);
      ……
      return retval;
  }
  
  int rdbLoadRio(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {
      ……
  
      // 加载具体的内容
      while(1) {
          sds key;
          robj *val;
  
          /* Read type. */
          // type占一个字节，先解析type
          if ((type = rdbLoadType(rdb)) == -1) goto eoferr;
  
          /* Handle special types. */
          if (type == RDB_OPCODE_EXPIRETIME) {        // 解析过期时间
              ……
          } else if (type == RDB_OPCODE_AUX) {        // 解析redis的额外信息
              ……
  
              if (((char*)auxkey->ptr)[0] == '%') {
                  ……
              } else if (!strcasecmp(auxkey->ptr,"repl-stream-db")) { // 主从同步相关
                  if (rsi) rsi->repl_stream_db = atoi(auxval->ptr);
              } else if (!strcasecmp(auxkey->ptr,"repl-id")) {
                  if (rsi && sdslen(auxval->ptr) == CONFIG_RUN_ID_SIZE) {     // 主从同步相关
                      memcpy(rsi->repl_id,auxval->ptr,CONFIG_RUN_ID_SIZE+1);
                      rsi->repl_id_is_set = 1;
                  }
              } else if (!strcasecmp(auxkey->ptr,"repl-offset")) {            // 主从同步相关
                  if (rsi) rsi->repl_offset = strtoll(auxval->ptr,NULL,10);
              } else {
                  ……
              }
  
              decrRefCount(auxkey);
              decrRefCount(auxval);
              continue; /* Read type again. */
          } else if (type == RDB_OPCODE_MODULE_AUX) {
              ……
          }
  		……
  
      // 整个rdb加载完
      return C_OK;
  
  		……
  }
  ```

- 将同步信息加载到cache_master里面

  ```c
  void loadDataFromDisk(void) {
      long long start = ustime();
      // 如果aof是开启的
      if (server.aof_state == AOF_ON) {
          ……
      } else {        // aof没开就加载rdb文件
          ……
          // 加载rdb文件
          if (rdbLoad(server.rdb_filename, &rsi,RDBFLAGS_NONE) == C_OK) {
              serverLog(LL_NOTICE, "DB loaded from disk: %.3f seconds",
                        (float) (ustime() - start) / 1000000);
  
              // 主从同步相关：当前是从库，并且有同步信息
              if ((server.masterhost ||
                   (server.cluster_enabled &&
                    nodeIsSlave(server.cluster->myself))) &&
                  rsi.repl_id_is_set &&
                  rsi.repl_offset != -1 &&
                  rsi.repl_stream_db != -1) {
                  memcpy(server.replid, rsi.repl_id, sizeof(server.replid));      // 设置主库的runid
                  server.master_repl_offset = rsi.repl_offset;                        // 设置偏移量
                  // 记载同步信息，创建client，记录同步信息，保存到server.cached_master
                  replicationCacheMasterUsingMyself();
                  selectDb(server.cached_master, rsi.repl_stream_db);
              }
          } ……
      }
  }
  ```



## 从库发起同步

这里与全量同步是一致的，直接看`slaveTryPartialResynchronization`函数

- 会从`server.cached_master`拿到同步信息，这里是加载rdb文件时会设置的
- 到这里就能向主库发起增量同步了

```c
int slaveTryPartialResynchronization(connection *conn, int read_reply) {
        // 有缓存了master的同步数据
        if (server.cached_master) {
            // PSYNC <runid> <offset>
            psync_replid = server.cached_master->replid;
            snprintf(psync_offset, sizeof(psync_offset), "%lld", server.cached_master->reploff + 1);
            serverLog(LL_NOTICE, "Trying a partial resynchronization (request %s:%s).", psync_replid, psync_offset);
        } else {
            ……
        }
  
        // 发送PSYNC命令
        reply = sendSynchronousCommand(SYNC_CMD_WRITE, conn, "PSYNC", psync_replid, psync_offset,NULL);
        if (reply != NULL) {
            serverLog(LL_WARNING, "Unable to send PSYNC to master: %s", reply);
            sdsfree(reply);
            connSetReadHandler(conn, NULL);
            return PSYNC_WRITE_ERROR;
        }
        return PSYNC_WAIT_REPLY;
}
```





## 主库处理增量同步

这里与全量同步流程入口一致，先尝试增量同步。成功增量同步就直接返回了

```c
void syncCommand(client *c) {
    ……

    // 如果是psync命令
    if (!strcasecmp(c->argv[0]->ptr, "psync")) {
        // 尝试部分同步
        if (masterTryPartialResynchronization(c) == C_OK) {
            server.stat_sync_partial_ok++;
            return;
        } else {        // 无法部分同步，只能全量同步
            ……
        }
    } else {        // sync命令
        ……
    }

    ……
}
```

- 尝试增量同步

  - 设置从库上线
  - 回复增量同步
  - 根据偏移量，把积压复制区的数据发送给从库

  ```c
  int masterTryPartialResynchronization(client *c) {
      ……
        
      // 判断可以进行增量同步
  
      // 设置从库上线
      c->flags |= CLIENT_SLAVE;
      c->replstate = SLAVE_STATE_ONLINE;
      c->repl_ack_time = server.unixtime;
      c->repl_put_online_on_ack = 0;
      listAddNodeTail(server.slaves, c);
      if (c->slave_capa & SLAVE_CAPA_PSYNC2) {
          buflen = snprintf(buf, sizeof(buf), "+CONTINUE %s\r\n", server.replid);
      } else {
          buflen = snprintf(buf, sizeof(buf), "+CONTINUE\r\n");
      }
    
    	// 回复增量同步
      if (connWrite(c->conn, buf, buflen) != buflen) {
          freeClientAsync(c);
          return C_OK;
      }
    
    	// 根据偏移量，把积压复制区的命令全部发送到client的待发送响应中，之后会响应给客户端（就像一个client向从服务器发送命令一样）
      psync_len = addReplyReplicationBacklog(c, psync_offset);
      ……
  
      // 更新从库数量
      refreshGoodSlavesCount();
  
      ……
  
      return C_OK;
  		……
  }
  ```

  到这里，主库就可以正常跟从库交流了



