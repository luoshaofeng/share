# Info

version：redis 6.0



# 列表对象

列表对象就1种编码方式：`quicklist`



# quicklist

quicklist主要由两部分构成：双向链表 + 压缩列表



## 压缩列表ziplist

压缩列表是链表的一个节点，多个压缩列表形成的双向链表，构成了quicklist

压缩列表是一种内存非常紧凑的结构，在一个连续地址保存多个元素，并且没有内存上的浪费。但是每次操作元素都要重新分配内存，有频繁的内存申请操作。



### 结构

ziplist由几部分组成，按照顺序分别是bytes，lastEntryOffset，entryCount，entry，endSize。除了entry外，其他字段所占用的字节数是固定的

bytes：表示当前整个ziplist占用的字节总数

lastEntryOffset：指向ziplist中最后一个entry的首地址，可以非常方便的找到最后一个元素。如果是空的ziplist，那么指向endSize。

entryCount：表示当前ziplist中有多少个entry

entry：ziplist中的一个元素，数据保存在entry中

endSize：固定值0xFF，表示这个ziplist的末尾

这几个字段在内存上是连续的。



一个空ziplist（不包含entry）的内存结构是这样的：

```c
#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))
#define ZIPLIST_END_SIZE        (sizeof(uint8_t))

unsigned int bytes = ZIPLIST_HEADER_SIZE + ZIPLIST_END_SIZE;
unsigned char *zl = zmalloc(bytes);
```



- ziplist头结构

  从ZIPLIST_HEADER_SIZE的定义可以看到，所占内存空间为2个4字节(32位)和1个2字节（16位）

  - bytes：头4字节（32位）用来存储整个ziplist占用的字节总数
  - lastEntryOffset：中间4字节（32位）用来储存ziplist中，最后一个entry的地址
  - entryCount：最后2字节（16位）用来存储ziplist中的entry数量

- ziplist尾结构

  从ZIPLIST_END_SIZE的定义可以看出，尾结构占用1个字节。在ziplist中，保存的是一个固定值0xFF。





### entry

entry是ziplist的一个元素对象，并且entry的大小不是固定的。除了保存"值"外，还需要保存一些其他值，以便我们能一个entry一个entry的遍历处理，以及正确的找到这个entry中的实际保存值。



entry由三个部分构成：prevlen，encoding和content

- prevlen：保存的是前一个entry所占用的字节数
- encoding：保存的是这个entry的编码值，根据这个值，可以找到content的位置
- content：实际存储元素的位置



- prevlen

  prevlen存储的值是前一个entry所占用的字节数。它可能是1个字节或者5个字节。取决于前一个entry的大小。

  当前一个entry占用的字节数小于等于254（0xFF(256)被endSize占用，0xFE(255)用来标识当前字段占用5字节）时，用1个字节保存。当大于254时，用5字节来保存前一个entry的大小，其中第一个字节固定为0xFE，标识当前这个字段是5字节的

- encoding

  元素值一般可以分为两个类型：整数和字符串。entry对这两种数据做了不同的编码，并且针对每种类型值储存的数据量不同也做了不同的编码。

  encoding头两位来表示是字符串还是数字。`11`表示存储的是一个数字，`非11`表示存储的是字符串

  - string类型

    对于string类型来说，encoding的长度不是固定的。encoding头两位为`非11`的标识。所以，头标识有三种可能性：`00`，`01`，`10`

    `00`：表示用6位来存储字符串的长度（1字节），其中第一个字节后6位参与长度信息的存储

    ```tex
    lpush key 'redis'
    那么redis这个值就会被存储到entry中，redis的长度为5，小于2^6，所以encoding的头两位应该用00表示，所以encoding的值为
    (0 << 6) | 5 =  00000000 | 00000101 = 00 000101（00为标识，000101为字符串的长度）
    ```

    `01`：表示用14位来存储字符串的长度（2字节），其中第一个字节后6位参与长度信息的存储

    ```tex
    同00的情况，假设要存储的字符串长度 >= 2^6，那么上面的结构就无法存储这个结构了，那么encoding应该为01开头
    假设字符串长度的二进制值为 01001000，那么encoding需要两个字节。
    第一个字节存储的值为
    (1 << 6) | (000000 01001000 >> 8) = 10000000 | 00000000 = 10000000
    第二个字节存储的值为
    01001000
    所以编码为 10000000 01001000
    ```

    `10`：表示用32位来存储字符串的长度（5字节），其中第一个字节不参与长度信息的存储

    ```tex
    这个不同于上面的，第一个字节不参与长度信息的存储，为固定值10000000
    后面四个字节的值就是int32所对应长度的值
    ```

  - 整数类型

    对于整数类型来说，encoding的长度固定为1字节。encoding头两位为11的标识。

    由于不同的整数级别，所用的存储长度不同。所以需要在`第3-4位`需要枚举出保存整数所需要的字节数。`int16`，`int32`，`int64`，`int24`，`int8`

    `00`：表示content用16位存储

    `01`：表示content用32位存储

    `10`：表示content用64位存储

    `11`：表示content用24位存储

    `0xFE`：这个比较特殊，用0xFE来表示用8位来存储content

    除了这些之外，当存储的值>=0 && <= 12时，将值存在encoding中，没有content

- content

  content所存储的内容看encoding。如果encoding是string类型，那么content存储的就是字符串。如果encoding是整数类型，那么content存储的就是整数



#### 解析entry结构

从这个entry结构我们能解析到什么数据

在redis中定义了这样的一个结构：

```c
typedef struct zlentry {
    // prevrawlen所用的编码长度，也就是存储prevrawlen，用了多少个字节值（1字节或者5字节）
    unsigned int prevrawlensize;
    // 上一个节点的长度
    unsigned int prevrawlen;
  
    // 编码使用字节大小
    unsigned int lensize; 
    // 这个元素的长度
    unsigned int len;
  
    // 头大小，prevrawlensize + lensize。就是prevlen和encoding所占用的字节大小
    unsigned int headersize;
    // 元素的编码
    unsigned char encoding;
    // 这个元素的头指针，指向的就是content
    unsigned char *p;
} zlentry;
```

注意，这个结构实际上不存在。这个只是用来辅助解析entry的，redis中定义了这个结构，但是没有存储这个结构的数据



redis是如何解析出来的

```c
void zipEntry(unsigned char *p, zlentry *e) {
    //从p中提取prevrawlensize和prevrawlen的值
    ZIP_DECODE_PREVLEN(p, e->prevrawlensize, e->prevrawlen);
    ZIP_DECODE_LENGTH(p + e->prevrawlensize, e->encoding, e->lensize, e->len);
    e->headersize = e->prevrawlensize + e->lensize;
    e->p = p;
}
```

- 解析prevlensize和prevrawlen

  - 先解析prevlensize的值，如果prevlensize是1个字节的，那么这个字节读取出来的数据就是prevlen
  - 如果prevlensize是5个字节的，那么后面4个字节读取出来的数据就是prevlen

  ```c
  #define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
      ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
      if ((prevlensize) == 1) {                                                  \
          (prevlen) = (ptr)[0];                                                  \
      } else if ((prevlensize) == 5) {                                           \
          assert(sizeof((prevlen)) == 4);                                        \
          memcpy(&(prevlen), ((char*)(ptr)) + 1, 4);                             \
          memrev32ifbe(&prevlen);                                                \
      }                                                                          \
  } while(0)
  ```

  解析prevlensize的值

  - ptr指向的地址是entry
  - 读取第一个字节ptr[0]，如果不是0xFE（ < ZIP_BIG_PREVLEN），那么就表示1个字节来存储前一个entry的长度；否则就是5个字节

  ```c
  #define ZIP_BIG_PREVLEN 254 // 0xFE
  
  #define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
      if ((ptr)[0] < ZIP_BIG_PREVLEN) {                                          \
          (prevlensize) = 1;                                                     \
      } else {                                                                   \
          (prevlensize) = 5;                                                     \
      }                                                                          \
  } while(0)
  ```

- 解析`encoding`，`lensize`和`len`

  p + e->prevrawlensize：p指针已经被挪到了encoding的位置了，所以ptr指向的是encoding

  - 提取encoding的值

  ```c
  #define ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do {                    \
      ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \
      if ((encoding) < ZIP_STR_MASK) {                                           \		// string类型编码，解析encoding取出长度
          if ((encoding) == ZIP_STR_06B) {                                       \		// 6位保存长度，占1个字节
              (lensize) = 1;                                                     \		
              (len) = (ptr)[0] & 0x3f;                                           \		// 把低6位的值取出来
          } else if ((encoding) == ZIP_STR_14B) {                                \		// 14位保存长度，占2个字节
              (lensize) = 2;                                                     \
              (len) = (((ptr)[0] & 0x3f) << 8) | (ptr)[1];                       \		// 把低14位的值取出来
          } else if ((encoding) == ZIP_STR_32B) {                                \		// 32位保存长度，占2个字节
              (lensize) = 5;                                                     \
              (len) = ((uint32_t)(ptr)[1] << 24) |                               \		// 把后面4个字节的值取出来
                      ((uint32_t)(ptr)[2] << 16) |                               \
                      ((uint32_t)(ptr)[3] <<  8) |                               \
                      ((uint32_t)(ptr)[4]);                                      \
          } else {                                                               \
              panic("Invalid string encoding 0x%02X", (encoding));               \
          }                                                                      \
      } else {                                                                   \
          (lensize) = 1;                                                         \		// int类型固定取1位
          (len) = zipIntSize(encoding);                                          \		// 根本encoding直接返回
      }                                                                          \
  } while(0)
  ```

  - 提取encoding值
    - 如果是int编码，保持encoding不变
    - 如果是string编码，只取头两位的值，其他位都置为0

  ```c
  #define ZIP_STR_MASK 0xc0           // 11000000
  
  #define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \
      (encoding) = (ptr[0]); \				// int类型直接取出来
      if ((encoding) < ZIP_STR_MASK) (encoding) &= ZIP_STR_MASK; \		// string类型只取头2位，其他位置0
  } while(0)
  ```

- 解析header

  - 这个大小就是prevlen和encoding所占用的字节大小

  ```c
  e->headersize = e->prevrawlensize + e->lensize;
  ```

- p

  指向content



所以，整个ziplist的结构就是

```tex
| bytes | tailEntryOffset | entryCount | entry1 | entry2 | …… | entryN | endSize |
```





## 双向链表

一个ziplist构成了链表的一个节点

双向链表的结构是这样的

```c
typedef struct quicklistNode {
    // 前一个元素
    struct quicklistNode *prev;
    // 后一个元素
    struct quicklistNode *next;
    // 压缩列表
    unsigned char *zl;
    // 整个压缩列表的字节数
    unsigned int sz;
    // ziplist的entry数
    unsigned int count : 16;
    // ziplist的编码存储方式：原始未压缩的ziplist；使用 LZF 算法压缩后的数据，quicklistLZF结构
    unsigned int encoding : 2;
    // 目前固定 ZIPLIST==2
    unsigned int container : 2;
    // 是否被解压过
    unsigned int recompress : 1;
    // 尝试压缩节点失败了。比如太小没必要压缩
    unsigned int attempted_compress : 1;
    // 预留位，未使用
    unsigned int extra : 10;
} quicklistNode;
```

### 添加新节点

当ziplist的字节总数 或者 entry数达到一定量时，就不能再往原来的ziplist添加数据了。这个时候需要新开一个节点

这个由`list-max-ziplist-size`配置项控制

- < 0（-1 到 -5）：表示ziplist的最大字节数，超过了就要新开一个节点了。从-1 到 -5依次增大
- = 0：使用默认的最大字节数（会被初始化为-2）
- 大于0：表示最多能有list-max-ziplist-size个entry，超过了就要新开一个节点了。同时也被默认的最大字节数限制



### 压缩节点

默认不开启节点压缩。

由`list-compress-depth`控制。0表示不压缩，配置n表示首尾n个节点不压缩

当添加新节点时，旧的节点就会被压缩



# quicklist

quicklist关联了整个双向链表，以及定义整个quicklist的属性。

结构如下：

```c
typedef struct quicklist {
    // 列表头
    quicklistNode *head;
    // 列表尾
    quicklistNode *tail;
    // 所有的ziplist上entry的数量
    unsigned long count;
    // quicklistNode的数量
    unsigned long len;
    // fill：控制什么时候创建新节点
    int fill : QL_FILL_BITS;
    // 压缩配置
    unsigned int compress : QL_COMP_BITS;
    // 命名书签数量
    unsigned int bookmark_count: QL_BM_BITS;
    // 命名书签，方便快速找到节点
    quicklistBookmark bookmarks[];
} quicklist;
```



